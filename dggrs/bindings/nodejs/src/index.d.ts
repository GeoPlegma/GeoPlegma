/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Dggrs {
  constructor(dggrs: string)
  add(a: number, b: number): number
  zonesFromBbox1(depth: number, densify: boolean, bbox?: Array<Array<number>> | undefined | null): JsZones
}

/**
 * The Zone struct has nested heap allocations (String, Vec<(f64,f64)>, Vec<String>), which means:
 * - Each String is 24 bytes (ptr, len, capacity) + heap data.
 * - Each (f64, f64) is fine in Rust, but Vec<(f64,f64)> is not a flat Vec<f64> in wasm.
 * - napi-rs will have to walk and serialize everything, which is slow for thousands of zones.
 * No napi-rs overhead per zone — you pass one pointer + length per field instead of millions of small objects.
 * Zero-copy — JS reads directly from WebAssembly memory.
 * Keeps geometry-heavy Zone struct in Rust for efficient calculations.
 * Scales to millions of zones without crashing the browser or blowing up memory usage.
 * Tradeoff
 * Pro: Hugely faster for large datasets
 * Con: JS side reconstruction is manual — you need to decode UTF-8 strings from byte arrays using TextDecoder and use offset tables.
 */
export interface JsZones {
  idOffsets: Array<number>
  utf8Ids: Array<number>
  centerX: Array<number>
  centerY: Array<number>
  vertexCount: Array<number>
  regionOffsets: Array<number>
  regionCoords: Array<number>
  childrenOffsets: Array<number>
  childrenIdOffsets: Array<number>
  childrenUtf8Ids: Array<number>
  neighborsOffsets: Array<number>
  neighborsIdOffsets: Array<number>
  neighborsUtf8Ids: Array<number>
}
